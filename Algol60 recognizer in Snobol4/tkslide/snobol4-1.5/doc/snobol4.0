SNOBOL4(1)                                                          SNOBOL4(1)



NNAAMMEE
       snobol4 - SNOBOL4 interpreter

SSYYNNOOPPSSIISS
       ssnnoobbooll44 [ _o_p_t_i_o_n_s ...  ] [ _f_i_l_e_(_s_) ...  ] [ _p_a_r_a_m_s ...  ]


DDEESSCCRRIIPPTTIIOONN
       This  manual  page describes a port of the original Bell Telephone Labs
       (BTL) Macro Implementation of SNOBOL4 to machines  with  ILP32  (32-bit
       int/long/pointer)  or  LP64 (64-bit long/pointer) C compilers by Philip
       L. Budne.  The language and its implementation are described in [1] and
       [2].   Extensions  from  Catspaw SNOBOL4+, SPITBOL and SITBOL have been
       added.  This page discusses only the changes/extensions.


   LLiimmiittaattiioonnss
       All aspects of the language are implemented except:

       +o      Trapping of arithmetic exceptions.

       +o      LLOOAADD(()) can be used to access external functions  on  most  plat-
              forms, but not all.  External functions can be statically linked
              (poor man's loading) into the snobol4 executable  on  AALLLL  plat-
              forms.   See  /usr/local/lib/snobol4/_v_e_r_s_i_o_n/load.txt  for  more
              information.


   CChhaannggeess
       The following behaviors have  been  changed  from  the  original  Macro
       SNOBOL4;

       +o      Listings  are  disabled  by default.  Default listing side (when
              enabled by --LLIISSTT or the --ll command line option is  LLEEFFTT.   List-
              ings  are  directed to standard output (or file specified by the
              --ll command line option.

       +o      Error messages, the startup banner and statistics  are  directed
              to  standard error.  Compilation error messages (including erro-
              neous lines) appear on standard error as well as  in  the  list-
              ings.   Error  messages  now  reference the source file name and
              line number.

       +o      Character set (see below).

       +o      The PPUUNNCCHH output variable no longer exists (see  TTEERRMMIINNAALL  vari-
              able below).

       +o      I/O is not performed using FORTRAN I/O.  The 3rd argument to the
              OOUUTTPPUUTT(()) and IINNPPUUTT(()) functions is interpreted as a string of I/O
              options (see below).

       +o      Control  lines and comment characters are valid after the end of
              string (;) statement separator.  Listing statement numbers  show
              the  statement  number of the LAST statement on the line (rather
              than the first).

       +o      Setting the &&AABBEENNDD keyword causes a core dump upon termination!

       +o      The value of the &&CCOODDEE keyword determines the exit status of the
              ssnnoobbooll44 application.

       +o      The  DDAATTEE(())  function  returns  strings  of the form: _M_M_/_D_D_/_Y_Y_Y_Y
              _H_H_:_M_M_:_S_S.  See extensions section for arguments  to  the  DDAATTEE(())
              function.

       +o      Keyword &&SSTTLLIIMMIITT now defaults to -1.  When &&SSTTLLIIMMIITT is less than
              zero there is no limit to the number of statements executed, and
              &&SSTTCCOOUUNNTT is not incremented.

       +o      VVAALLUUEE  tracing  applies to variables modified by immediate value
              assignment ($ operator) and value assignment (. operator) during
              pattern matching.

       +o      The BBAACCKKSSPPAACCEE(()) function is not implemented. Use the SSEETT(()) func-
              tion instead.

       +o      I/O unit numbers up to 256 can be used.

       +o      Attempts to output on a closed unit generates  a  fatal  "Output
              error".


   CChhaarraacctteerr sseett
       ssnnoobbooll44(1)  is  8-bit  clean,  and  uses the native character set.  Any
       8-bit byte is accepted as a SNOBOL datum or in a string constant  of  a
       SNOBOL  source  program.   The  value  of  the SNOBOL protected keyword
       &&AALLPPHHAABBEETT is a 256-character string of all bytes  from  0  to  255,  in
       ascending order.

       On  ASCII-based  systems, any character with the 8th bit set is treated
       as "alphabetic", and can start, or be used in identifiers  and  labels.
       This  includes  characters  from the "upper half" of national character
       sets and all bytes resulting from the UTF-8 encoding of Unicode charac-
       ters.

       Programs  may  be  entered in mixed case; By default lower case identi-
       fiers are folded to upper case (see &&CCAASSEE and --CCAASSEE extensions  below).
       Case  folding  is performed by using the C library iisslloowweerr(3) test, and
       then using ttoouuppppeerr(3) to convert the  lower-case  characters  to  upper
       case.  When using UTF-8 encoded characters in code, case folding should
       be disabled, to prevent any bytes which appear to be lower case in  the
       current locale from being modified.

       The  following operator character sequences are permitted and represent
       a cross between PDP-10 Macro SNOBOL, SITBOL and Catspaw SPITBOL usage:
       Exponentiation:     ^ **
       Alternation:        | !
       Unary negation:     ~ \
       Assignment:         = _
       Comment line:       * # | ; !
       Continuation line:  + .

       Both square brackets ([]) and angle brackets (<>) may be used  to  sub-
       script  arrays  and tables.  The TTAABB (ASCII 9) character is accepted as
       whitespace.  Note that the use of the pound sign  for  comments  allows
       use  of  the  shell  interpreter  sequence  at the top of a file (e.g.,
       "#!/usr/local/bin/snobol4 -b").  Underscore  (_)  and  period  (.)  are
       legal within identifiers and labels.


   EExxtteennssiioonnss
       AARRRRAAYY//TTAABBLLEE access
              Multiple  AARRRRAAYY  and/or  TTAABBLLEE  index operations may appear in a
              row, without having to resort to use of the EELLEEMMEENNTT function, so
              long as no intervening spaces (or line continuations) appear.

       BBRREEAAKKXX(())
              The  BBRREEAAKKXX(()) function is a pattern function used for fast scan-
              ning.  BBRREEAAKKXX((_s_t_r))  is  equivalent  to  BBRREEAAKK((_s_t_r))  AARRBBNNOO((LLEENN((11))
              BBRREEAAKK((_s_t_r)))).   In  other words BREAKX matches a sequence of ever
              larger strings terminated by a break set.  BREAKX can be used as
              a  faster  matching  replacement  for  AARRBB: BBRREEAAKKXX((''SS'')) ''SSTTRRIINNGG''
              always runs faster than AARRBB  ''SSTTRRIINNGG''  since  it  only  attempts
              matching ''SSTTRRIINNGG'' at locations where an ''SS'' has been detected.

       Case folding
              By  default  the  compiler  folds  identifiers and directives to
              upper case, so programs can be entered in either case.  To  dis-
              able  case  folding  use the directive --CCAASSEE 00 oorr --CCAASSEE.  To re-
              enable case folding use directive --CCAASSEE _n where _n is a  non-zero
              integer.   The  status  of case folding may be examined and con-
              trolled from a running program by the unprotected system keyword
              &&CCAASSEE.

       CCHHAARR(())
              The  CCHHAARR(())  function takes an integer from 0 to 255 and returns
              the nth character in &&AALLPPHHAABBEETT.

       DDAATTEE(())
              For compatibility with new versions of Catspaw SPITBOL,  DDAATTEE((00))
              returns  strings  of  the  form  _M_M_/_D_D_/_Y_Y  _H_H_:_M_M_:_S_S, and DDAATTEE((22))
              returns strings of the form _Y_Y_Y_Y_-_M_M_-_Y_Y _H_H_:_M_M_:_S_S.  With any other
              arguments   DDAATTEE(())   returns  strings  of  the  form  _M_M_/_D_D_/_Y_Y_Y_Y
              _H_H_:_M_M_:_S_S.

       &&DDIIGGIITTSS
              The protected keyword &&DDIIGGIITTSS contains the string 00112233445566778899 for
              compatibility with the Unicon/Icon languages!

       --EERRRROORR//--NNOOEERRRROORRSS
              Directives  --EERRRROORR  and  --NNOOEERRRROORRSS  control execution of program
              with compiler errors.  If the --EERRRROORR  directive  is  given,  the
              program will be executed (but any attempt to execute a statement
              with a compiler error will cause a fatal execution  error).   By
              default  programs with compiler errors will not be started, this
              can be restored using --NNOOEERRRROORRSS.

       &&EERRRRTTEEXXTT
              After a statement with an error has been handled due to  a  non-
              zero  value  in  &&EERRRRLLIIMMIITT,  the protected keyword &&EERRRRTTEEXXTT will
              contain the error message.  See the  DDIIAAGGNNOOSSTTIICCSS  section  below
              for explanations of errors, and whether they are fatal or not.

       --EEXXEECCUUTTEE//--NNOOEEXXEECCUUTTEE
              Directives  --EEXXEECCUUTTEE  and  --NNOOEEXXEECCUUTTEE  control execution of pro-
              grams.  If the --NNOOEEXXEECCUUTTEE directive is given, the  program  will
              be  not executed after compilation.  --EEXXEECCUUTTEE cancels any previ-
              ous --NNOOEEXXEECCUUTTEE.

       FFIILLEE__AABBSSPPAATTHH(())//FFIILLEE__IISSDDIIRR(())
              FFIILLEE__AABBSSPPAATTHH((_s_t_r_i_n_g)) is  a  predicate  which  returns  the  null
              string  if  its  argument  is an absolute file path, and returns
              failure if the path is relative.  FFIILLEE__IISSDDIIRR((_s_t_r_i_n_g)) is a predi-
              cate  which returns the null string if its argument is the path-
              name of a directory, and returns failure if not.

       FFRREEEEZZEE(())//TTHHAAWW(())
              The FFRREEEEZZEE(()) function prohibits creation of new entries  in  the
              referenced table.  This is useful once a table has been initial-
              ized to avoid creating empty entries on lookups that fail.  This
              can  greatly improve program speed, since frozen tables will not
              become clogged with empty entries.   Lookups  for  uninitialized
              entries  will  return  the null string.  Attempts to assign to a
              non-existent entry will cause  a  "Variable  not  present  where
              required"  error. The TTHHAAWW(()) function restores normal entry cre-
              ation behavior.

       FFUUNNCCTTIIOONN(())
              The FFUUNNCCTTIIOONN(()) predicate evaluates  its  argument  as  a  string
              (with  case  folding), and returns the null string if a function
              with that name exists and fails if it does not.  The  FFUUNNCCTTIIOONN(())
              predicate exists in SITBOL.

       &&GGCCTTIIMMEE
              The  protected  keyword  &&GGCCTTIIMMEE  contains a RREEAALL number of mil-
              liseconds of execution time spent in the garbage collector.

       &&GGTTRRAACCEE
              If the unprotected keyword &&GGTTRRAACCEE set to a non-zero value, each
              time  a  garbage  collection  is  run, a trace message is output
              indicating the source file and line number of the current state-
              ment,  how  long  the GC took, and how many units of storage are
              now free. If positive, the value of &&GGTTRRAACCEE will be  decremented
              after it is tested.

       --HHIIDDEE  The  --HHIIDDEE directive stops listing, and assignment of new state-
              ment numbers.  It is used to hide the source code for the ssddbb(1)
              source code debugger.

       HHOOSSTT(())
              A  limited  simulation of the SPITBOL HHOOSSTT(()) function (with lib-
              eral implementation specific extensions) is included.

              The --IINNCCLLUUDDEE file hhoosstt..ssnnoo contains symbolic defines  for  these
              (and mmaannyy other) function codes.

              HHOOSSTT(()) with no parameters returns a string describing the system
              the program is running on.  The  string  contains  three  parts,
              separated  by  colons.   The  first  part describes the physical
              architecture, the second describes the operating system, and the
              third  describes  the language implementation name. NOTE! Archi-
              tecture names come from the uunnaammee(3) library call,  and  may  be
              different for the same hardware when running different operating
              systems.  An example  value:  _i_3_8_6_:_F_r_e_e_B_S_D  _1_0_._0_-_A_L_P_H_A_2_:_C_S_N_O_B_O_L_4
              _1_._5

              HHOOSSTT((00))  returns  a string containing the command line parameter
              supplied to the --uu option, if any.  If no --uu option  was  given,
              HHOOSSTT((00)) returns the concatenation of all user parameters follow-
              ing the input filename(s).

              HHOOSSTT((11,,_s_t_r_i_n_g)) passes the string  to  the  ssyysstteemm(3)  c  library
              function, and returns the subprocess exit status.

              HHOOSSTT((22,,_n))  for  integer _n returns the _n'th command line argument
              (regardless of whether the argument was  the  command  name,  an
              option,  a filename or a user parameter) as a string, or failure
              if _n is out of range.

              HHOOSSTT((33)) returns an integer for use with HHOOSSTT((22))  indicating  the
              first command line argument available as a user parameter.

              HHOOSSTT((44,,_s_t_r_i_n_g))  returns  the  value  of the environment variable
              named _s_t_r_i_n_g.

       --IINNCCLLUUDDEE
              The --IINNCCLLUUDDEE directive causes the compiler  to  interpolate  the
              contents  of the named file enclosed in single or double quotes.
              Any filename will be included only once, this can be  overridden
              by  appending a trailing space to the filename.  Trailing spaces
              are removed from the filename before use.  If the  file  is  not
              found  in  the current working directory an attempt will be made
              to find it in the directories  specified  in  the  search  path.
              --CCOOPPYY  is  a  synonym  for --IINNCCLLUUDDEE for compatibility with SPIT-
              BOL/370.

       IIOO__FFIINNDDUUNNIITT(())
              The IIOO__FFIINNDDUUNNIITT(()) function returns an unused I/O unit number for
              use  with  the  IINNPPUUTT(()) or OOUUTTPPUUTT(()) functions.  IIOO__FFIINNDDUUNNIITT(()) is
              meant for use in subroutines which can be reused.  IIOO__FFIINNDDUUNNIITT(())
              will never return a unit number below 20.

       LLAABBEELL(())
              The  LLAABBEELL(())  predicate evaluates its argument as a string (with
              case folding), and returns the null string if a label with  that
              name  has  been  defined, and fails if it does not.  The LLAABBEELL(())
              predicate was copied from Steve Duff's version of Macro SPITBOL.
              SITBOL  has  a LLAABBEELL ffuunnccttiioonn tthhaatt ttaakkeess aann ooppttiioonnaall lliinnee ooffffsseett
              from the label and returns a CCOODDEE pointer.

       &&LLIINNEE//&&FFIILLEE//&&LLAASSTTLLIINNEE//&&LLAASSTTFFIILLEE
              The &&LLIINNEE and &&FFIILLEE keywords can be used to determine the source
              file  and  file line associated with the current statement.  The
              &&LLAASSTTLLIINNEE and &&LLAASSTTFFIILLEE return the source  file  and  file  line
              associated  with the previous statement (and are useful in TTRRAACCEE
              and SSEETTEEXXIITT handlers.

       --LLIINNEE
              The --LLIINNEE directive can be used to alter SNOBOL's  idea  of  the
              current  source  file  and  line (ie; for use by preprocessors).
              --LLIINNEE takes a line number and an optional  quoted  string  file-
              name.

       Lexical comparison
              A  full  set of lexical (string) comparison predicates have been
              added to complement the standard LLGGTT(()) function;  LLEEQQ(()),  LLGGEE(()),
              LLLLEE(()), LLLLTT(()), LLNNEE(()).

       LLPPAADD(())//RRPPAADD(())
              The  LLPPAADD(())  and  RRPPAADD(()) functions take the first argument (sub-
              ject) string, and pad it out to the length specified in the sec-
              ond  argument,  using  the first character of the optional third
              argument.  If the third argument is  missing,  or  is  the  null
              string,  spaces  will  be used for padding.  The subject will be
              returned unmodified if already long enough.

       &&MMAAXXIINNTT
              The protected keyword  &&MMAAXXIINNTT  contains  the  largest  positive
              integer value that can be represented by the IINNTTEEGGEERR data type.

       Named files
              Filenames  can be supplied to the IINNPPUUTT(()) and OOUUTTPPUUTT(()) functions
              via an optional fourth argument.

              The filename - (hyphen) is interpreted as stdin on  IINNPPUUTT(())  and
              stdout on OOUUTTPPUUTT(()).

              If the filename begins with a vertical bar (|), the remainder is
              used as a shell command whose stdin (in the case of OOUUTTPPUUTT(())) or
              stdout  (in  the  case of IINNPPUUTT(())) will be connected to the file
              variable via a pipe.  If a pipe is opened by  INPUT()  input  in
              "update" mode, the connection will be bi-directional (on systems
              with socketpair and Unix-domain sockets).  See below for how  to
              associate a variable for I/O in both directions.

              If the filename begins with two vertical bars (||) the remainder
              is used as a shell  command  executed  with  stdin,  stdout  and
              stderr attached to the slave side of a pseudo-terminal (pty), if
              the system C library contains the ffoorrkkppttyy(3)  routine.   Use  of
              ptys  are necessary when the program to be invoked cannot be run
              without a "terminal" for I/O.  See below on how to properly  as-
              sociate the I/O variable.

              The  magic  filenames  //ddeevv//ssttddiinn,  //ddeevv//ssttddoouutt, and //ddeevv//ssttddeerrrr
              refer to the current process standard input, standard output and
              standard  error  I/O  streams respectively regardless of whether
              those special filenames exist on your system.

              The magic pathname //ddeevv//ffdd//_n_, opens a new I/O stream  associated
              with file descriptor number _n.

              The  magic  pathname  //ttccpp//_h_o_s_t_n_a_m_e//_s_e_r_v_i_c_e  can be used to open
              connection to a TCP server. If the path  ends  in  the  optional
              suffix  //pprriivv  the  local address will be bound to a port number
              below 1024, if process privileges allow.   //uuddpp//_h_o_s_t_n_a_m_e//_s_e_r_v_i_c_e
              behaves similarly for UDP.

              The  magic  pathname  //ddeevv//ttmmppffiillee  opens an anonymous temporary
              file for reading and writing, see ttmmppffiillee(3).

              On VMS, Win32, and MS-DOS the pathnames //ddeevv//nnuullll  and  //ddeevv//ttttyy
              are magical, and refer to the null device, and the user's termi-
              nal/console, respectively.

       OORRDD(())
              The OORRDD(()) function returns the ordinal value (zero  to  255)  of
              the  first  character in its string argument (the inverse of the
              CCHHAARR(()) function).

       &&PPAARRMM
              The entire command line is available  via  the  &&PPAARRMM  protected
              keyword  for  compatibility  with  Catspaw  SNOBOL4+. Use of the
              SPITBOL compatible HHOOSSTT(()) function is preferable, as it makes it
              possible to tell if a positional parameter containing spaces was
              passed in using shell quote characters.

       &&PPII
              The protected keyword &&PPII contains value  of  the  transendental
              number _p_i.

       RREEAALL numbers in IINNTTEEGGEERR contexts
              RREEAALL  numbers  (or  strings convertible to RREEAALL) are accepted in
              all contexts which previously required  an  IINNTTEEGGEERR  (or  string
              convertible  to  IINNTTEEGGEERR).   Contexts  include  TTAABBLLEE(()), IITTEEMM(()),
              array indices, IINNPPUUTT(()), OOUUTTPPUUTT(()),, SSEETT(()), keyword values, CCHHAARR(()),
              RRPPAADD(()),  LLPPAADD(()),  FFIIEELLDD(()),  CCOOLLLLEECCTT(()),  DDUUMMPP(()), DDUUPPLL(()), OOPPSSYYNN(()),
              SSUUBBSSTTRR(()).

       RREEVVEERRSSEE(())
              RREEVVEERRSSEE(()) returns its subject string in reverse order.

       Scientific notation
              RREEAALL number syntax has been expanded to allow exponents  of  the
              form:
              _A_N_Y_(_'_E_e_'_) _(_'_+_' _| _'_-_' _| _'_'_) _S_P_A_N_(_'_0_1_2_3_4_5_6_7_8_9_'_).  Exponential for-
              mat reals need not contain a decimal point.

       SSEERRVV__LLIISSTTEENN(())
              The SSEERRVV__LLIISSTTEENN(()) function makes SNOBOL4 into a  network  server
              process,  and  takes  three STRING arguments: FAMILY, TYPE, SER-
              VICE.  FAMILY must be either "inet" for an Internet Protocol  v4
              socket,  "inet6"  for  an Internet Protocol v6 socket, or "unix"
              for a local ("unix domain") socket.  The second  argument,  TYPE
              must be "stream", and the third argument, SERVICE must be a port
              number or service name (for an internet socket), or  a  pathname
              (for  a  "unix"  socket).   SERV_LISTEN()  listens  for incoming
              requests, accepts them, then "forks" a child process and returns
              an integer file descriptor which can be opened for bidirectional
              I/O using a "/dev/fd/n" magic pathname.  The original ("parent")
              process  never  returns from the SERV_LISTEN() call.  This func-
              tion is only available on systems with the "fork"  system  call,
              which  makes  a  child process which is an identical copy of the
              parent process.

       SSEETT(())
              The SSEETT(()) function can be used to seek the file  pointer  of  an
              open file.  The first argument is an I/O unit number, the second
              is an integer offset.  The third argument, an integer determines
              from  wwhheennccee  the  file  pointer will be adjusted.  If whence is
              zero the starting point is the beginning of the file, if  whence
              is  one,  the starting point is the current file pointer, and if
              whence is two, the starting point is the end of the file.  SSEETT(())
              returns the new file pointer value.  On systems with 64-bit file
              pointers and 32-bit integers (ie; 4.4BSD  on  i386)  the  return
              value  will be truncated to 32-bits, and only the first and last
              4 gigabytes of a file can be accessed directly.

       SSIITTBBOOLL file functions
              FFIILLEE((_s_t_r_i_n_g)) is a predicate which returns the null string if its
              argument is the name of a file that exists, and fails if it does
              not.  DDEELLEETTEE((_s_t_r_i_n_g)) is a predicate which tries  to  remove  the
              file   named   by   its   argument,  and  fails  if  it  cannot.
              RREENNAAMMEE((_s_t_r_i_n_g_1,,_s_t_r_i_n_g_2)) is a predicate which attempts to  rename
              the  file named by _s_t_r_i_n_g_2 to the file named by _s_t_r_i_n_g_1.  Unlike
              the SSIITTBBOOLL version, if  the  target  file  exists,  it  will  be
              removed.

       SSNNOOBBOOLL44++ real functions
              EEXXPP(()),  LLOOGG(()) and CCHHOOPP(()) functions are available for compatibil-
              ity with SNOBOL4+.  EEXXPP(())  returns  the  value  _e  _*_*  _x,  LLOOGG(())
              returns  the  natural logarithm of its REAL argument, and CCHHOOPP(())
              truncates the fractional part of  its  REAL  argument  (rounding
              towards  zero), and returns a REAL.  LLNN(()) is an alias for LLOOGG(()),
              for compatibility with Catspaw SPITBOL.

       SSOORRTT(())//RRSSOORRTT(())
              The SSOORRTT(()) and RRSSOORRTT(()) functions take two arguments.  The  first
              can  be either an array or a table.  If the first argument is an
              array, it may be singly-dimensioned in  which  case  the  second
              argument,  if  non-null should indicate the name of a field of a
              programmer defined data type to use  to  access  the  sort  key.
              Otherwise  the  first  argument  should  be a table or a doubly-
              dimensioned array, in which case  the  second  argument  may  an
              integer  indicating  the  array column on which to sort.  If the
              second argument is null, it is taken to be 1.  The array (or ta-
              ble)  is  not  modified;  a new array is allocated and returned.
              SSOORRTT(()) sorts elements in ascending order, while RRSSOORRTT(()) sorts in
              descending order.

              Example:  for  a table _T_A_B of integers, indexed by strings being
              used to tabulate word counts  _F_R_E_Q  _=  _R_S_O_R_T_(_T_A_B_,_2_)  returns  an
              array  such that _F_R_E_Q_<_1_,_1_> contains the most frequent word while
              _F_R_E_Q_<_1_,_2_> contains the  number  of  occurrences  of  that  word.
              While  _W_O_R_D_S _= _S_O_R_T_(_T_A_B_,_1_) returns an array with the rows by the
              lexicographical ordering of the words; _W_O_R_D_S_<_1_,_1_>  contains  the
              lexicographically  first word and _W_O_R_D_S_<_1_,_2_> contains the number
              of occurrences of that word.

       SSPPIITTBBOOLL operators
              The SPITBOL scan (?) and  assignment  (=)  operators  have  been
              added.   A  pattern  match  can appear within an expression, and
              returns the matched string as its value.   Similarly  assignment
              can  appear in an expression, and returns the assigned value. An
              assignment after a scan (ie; _S_T_R_I_N_G _? _P_A_T_T_E_R_N _= _V_A_L_U_E)  performs
              a  scan  and  replace.  Assignment is right associative, and has
              the lowest precedence, while scan is left associative and has  a
              precedence just higher than assignment.

              The  SPITBOL  selection/alternative  construction can be used in
              any expression.  It  consists  of  a  comma  separated  list  of
              expressions  inside  parentheses.  The expressions are evaluated
              until one succeeds, and its value is returned.   Abuse  of  this
              construction may result in incomprehensible code.

              The  type NNUUMMEERRIICC with CCOONNVVEERRTT(()) and the removal of leading spa-
              ces from strings converted to numbers (implicitly or explicitly)
              are  also  legal  when  SPITBOL extensions are enabled.  SPITBOL
              extensions can be enabled and disabled using the --PPLLUUSSOOPPSS direc-
              tive.   --PPLLUUSSOOPPSS 00 or --PPLLUUSSOOPPSS disables SPITBOL operators, while
              --PPLLUUSSOOPPSS _n where _n is a non-zero integer enables them.   SPITBOL
              extensions are enabled by default.

       SPITBOL SSEETTEEXXIITT(()) function
              The  argument to SSEETTEEXXIITT(()) is a label to which control is passed
              if a subsequent error occurs, providing that the  value  of  the
              keyword &&EERRRRLLIIMMIITT is non-zero.  The value of &&EERRRRLLIIMMIITT is decre-
              mented when The error trap occurs.  A SSEETTEEXXIITT(()) call with a null
              argument  causes  cancellation  of  the intercept.  A Subsequent
              error will terminate execution as usual with an  error  message.
              The  result returned by SSEETTEEXXIITT(()) is the previous intercept set-
              ting (i.e., a label name or null if no intercept is set).   This
              can  be  used  to save and restore the SSEETTEEXXIITT(()) conditions in a
              recursive environment.  The error intercept routine may  inspect
              &&EERRRRTTYYPPEE and take one of the following actions:

              1.   Terminate  execution  by transferring to the  special label
              AABBOORRTT.  This causes error processing  to  resume  as  though  no
              error intercept had been set.

              2.   Branching to  the  special  label CCOONNTTIINNUUEE causes execution
              to resume by taking the failure exit of the statement in error.

              3.  Branching to  the  special  label SSCCOONNTTIINNUUEE causes execution
              to resume at the point of interruption.

              4.  If  the  error occurred inside a function (&&FFNNCCLLEEVVEELL is non-
              zero), branch to label RREETTUURRNN, FFRREETTUURRNN, NNRREETTUURRNN.

              The occurrence of an error cancels  the  error  intercept.   The
              error  intercept  routine  must reissue the SSEETTEEXXIITT(()) Error han-
              dlers cannot be nested: only one copy  of  the  saved  execution
              state is kept.

       SSQQRRTT(())
              The  SSQQRRTT(())  function  is available for compatibility with SPARC
              SPITBOL.  SSQQRRTT(()) fails if the argument is negative, but does not
              cause a fatal error.

       SSSSEETT(())
              Experimental  "scaled set" function.  Takes arguments unit, off-
              set, whence, and scale.  The first three are  analogous  to  the
              same  arguments  for  the SSEETT(()) function.  The last parameter is
              used as a multiplicative scaling factor on the ooffffsseett parameter,
              and  as a divisor on the return value.  When used in combination
              with relative SSEETT(()) calls (whence of one), any file  offset  can
              be  achieved,  even when system file offsets are larger than can
              be represented in a SNOBOL4 IINNTTEEGGEERR.  Support for "Large  Files"
              is  enabled  when  available,  but  not all file systems support
              them.

       &&SSTTEEXXEECC
              The protected keyword &&SSTTEEXXEECC contains the number of  statements
              executed, regardless of the value of &&SSTTLLIIMMIITT.

       SSUUBBSSTTRR(())
              SSUUBBSSTTRR(())  takes  a  subject  string  as  its first argument, and
              returns the substring starting at the position specified by  the
              second argument (one-based) with a length specified by the third
              argument.  If the third argument is missing or zero, the remain-
              der of the string is returned.

       TTEERRMMIINNAALL I/O variable
              The variable TTEERRMMIINNAALL is associated with the standard error file
              descriptor for both input and output.

       TTRRAACCEE(()) function type argument
              The second argument of the TTRRAACCEE(()) function can  be  abbreviated
              to  a  single  letter:  CC  (CALL),  FF (FUNCTION), KK (KEYWORD), LL
              (LABEL), RR (RETURN), or VV (VALUE) as in Macro SPITBOL.

       Trig functions
              AATTAANN(()), SSIINN(()), CCOOSS(()) and TTAANN(()) functions are available for  com-
              patibility  with  SPARC  SPITBOL.   SSIINN(()),  CCOOSS(()) and TTAANN(()) take
              arguments in radians.  AATTAANN(()) returns the principal value of the
              arc tangent of its REAL argument.

       &&UUCCAASSEE//&&LLCCAASSEE
              Protected  keywords  &&UUCCAASSEE  and  &&LLCCAASSEE contain upper and lower
              case characters respectively.

       VVDDIIFFFFEERR(())
              The VVDDIIFFFFEERR(()) function takes two arguments,  if  they  DDIIFFFFEERR(()),
              the  first argument's value is returned.  This is intended to be
              used in contexts where _D_I_F_F_E_R_(_X_) _X  would  otherwise  have  been
              used.   The VVDDIIFFFFEERR(()) function was copied from Steve Duff's ver-
              sion of Macro SPITBOL.


   II//OO AAssssoocciiaattiioonnss
       I/O is performed by associating a variable name  with  a  numbered  I/O
       unit  using the IINNPPUUTT(()) and OOUUTTPPUUTT(()) functions.  The following associa-
       tions are available by default;

       Variable  Unit      Association
       IINNPPUUTT     5         standard input
       OOUUTTPPUUTT    6         standard output
       TTEERRMMIINNAALL  7         standard error (output)
       TTEERRMMIINNAALL  8         /dev/tty (input)


   II//OO OOppttiioonnss
       The third argument of the IINNPPUUTT(()) and OOUUTTPPUUTT(()) functions is interpreted
       as a string of single letter options, commas are ignored.  Some options
       effect only the I/O variable named in the first argument, others effect
       any variable associated with the unit number in the second argument.

       _d_i_g_i_t_s A  span of digits will set the input record length for the named
              I/O variable.  This controls the maximum  string  that  will  be
              returned  for regular text I/O, and the number of bytes returned
              for binary I/O.  Record length is per-variable association; mul-
              tiple  variables  may be associated with the same unit, but with
              different record lengths.  The default record length  for  input
              is 1024; longer lines will be silently truncated.

       AA      For  OOUUTTPPUUTT(())  the unit will be opened for append access  (no-op
              for IINNPPUUTT(())).

       BB      The unit will be opened for binary  access.   On  input  newline
              characters  have  no special meaning; the number of bytes trans-
              ferred depends on record length (see above). On output  no  new-
              line  is  appended.   For terminal devices, all I/O to this unit
              will be done without special processing for line editing or EOF,
              while  characters  which  deliver signals (interrupt, kill, sus-
              pend) are still processed.  Units opened on  the  same  terminal
              device  entry  operate  independently; some can use binary mode,
              while others operate in text mode.

       CC      Character at a time I/O.  A synonym for BB,,11.

       TT      Terminal mode.  No newline characters are added on  output,  and
              any  newline  characters  are  returned on input.  Terminal mode
              effects only the referenced unit.  Terminal mode is  useful  for
              outputting prompts in interactive programs.

       QQ      Quiet  mode.   Turns  off input echo on terminals.  Effects only
              input from this unit.

       UU      Update mode.  The unit is opened  for  both  input  and  output.
              Here is how to associate a variable for I/O in both directions:

                      unit = IO_FINDUNIT()
                      INPUT(.name, unit, 'U', 'filepath')
                      OUTPUT(.name, unit)

              Useful situations for this when filepath is //ddeevv//ffdd//_n where _n is
              a file descriptor number returned by SSEERRVV__LLIISSTTEENN,, filepath spec-
              ifies  a  pipe  (|command) or pseudo-terminal (||command) paths.
              The above sequence is also useful with when combined with  fixed
              record  length,  binary  mode  and the SSEETT(()) function for I/O to
              preexisting files.  Performing OOUUTTPPUUTT(()) first will create a reg-
              ular  file if it does not exist, but will also truncate a preex-
              isting file!

       WW      Unbuffered writes.  Each output variable  assignment  causes  an
              I/O transfer to occur, rather than collecting the data in a buf-
              fer for efficiency.


OOPPTTIIOONNSS
       --bb        Toggle startup banner output (by default on).

       --dd _D_D_D    Allocate "dynamic storage" region of _D_D_D descriptors for pro-
                 gram  code  and  data. A suffix of kk multiplies the number by
                 1024, a suffix of mm multiplies  the  number  by  1048576.   A
                 larger dynamic region may result in fewer garbage collections
                 (storage regenerations), however large values may cause  exe-
                 cution  to  slow  down when large amounts of garbage collect.
                 Most programs do not need an increased dynamic region to run.
                 If  your  program terminates with an "Insufficient storage to
                 continue" message you need to increase  the  dynamic  storage
                 region  size.   The  --hh  option  displays the default dynamic
                 region size.

       --ff        Toggle folding of identifiers to upper case  (see  --CCAASSEE  and
                 &&CCAASSEE).

       --gg        Enable garbage collection tracing (sets &&GGTTRRAACCEE to -1).

       --hh        Give  help.  Shows  usage message, includes default sizes for
                 "dynamic region" and pattern match stack.

       --kk        Toggle running programs with compilation errors  (see  --EERRRROORR
                 and --NNOOEERRRROORRSS extensions).  By default programs with compila-
                 tion errors will not be run.

       --ll _L_I_S_T_I_N_G_F_I_L_E
                 Enable listing output to the named file. The default  listing
                 side is LLEEFFTT.

       --nn        Toggle  running  programs after compilation (see --EEXXEECCUUTTEE and
                 --NNOOEEXXEECCUUTTEE extensions).  By default programs  are  run  after
                 compilation.

       --pp        Toggle SPITBOL extensions (also controlled by --PPLLUUSSOOPPSS).

       --rr        Toggle  reading  IINNPPUUTT  from  input  file(s) after EENNDD label.
                 Otherwise IINNPPUUTT defaults (back) to standard input after  pro-
                 gram compilation is complete.

       --ss        Toggle termination statistics (off by default).

       --uu _p_a_r_a_m_s specifies a parameter string available via HHOOSSTT((00)).

       --vv        Show version and exit.

       --zz        Show  directory search path in use (including --II options) and
                 exit.

       ----        Terminates processing items as options. Any remaining strings
                 are treated as files or user parameters.

       --II _d_i_r_e_c_t_o_r_y
                 Appends  directory  argument  to  include search path (before
                 elements from the SSNNOOLLIIBB or SSNNOOPPAATTHH environment variables).

       --LL _f_i_l_e   Load source file before others on command line.  May be  used
                 multiple  times.   Used  to  preload  the  ssddbb(1) source code
                 debugger.

       --MM        Specifies that all items  left  on  the  command  line  after
                 option processing is complete are to be treated as filenames.
                 The files are read in turn until an EENNDD  statement  is  found
                 (Any  remaining  data  is available via the IINNPPUUTT variable if
                 the --rr option is also given).  A ---- terminates processing  of
                 arguments  as files, and makes the remaining arguments avail-
                 able as user parameters (see the HHOOSSTT(()) function).

       --PP _D_D_D    Allocate _D_D_D descriptors for the pattern match stack.  A suf-
                 fix  of kk multiplies the number by 1024, a suffix of mm multi-
                 plies the number by 1048576.  The pattern match stack is used
                 to  save  backtracking and conditional assignment information
                 during pattern matching.  If your program terminates with  an
                 "Overflow  during  pattern  matching"  message (Error 16) you
                 need to increase the  pattern  match  stack  size.    The  --hh
                 option displays the default pattern match stack size.

       --SS _D_D_D    Allocate _D_D_D descriptors for the interpreter stack.  A suffix
                 of kk multiplies the number by 1024, a suffix of mm  multiplies
                 the  number  by  1048576.   The interpreter stack is used for
                 saving data, and passing parameters to  internal  procedures.
                 If  your  program terminates with an "Stack overflow" message
                 (Error 21) you need to increase the interpreter  stack  size.
                 A  common  reason  for  needing additional stack space is for
                 tracing deeply nested DATA() structures during  garbage  col-
                 lection.   The  --hh  option  displays  the default interpreter
                 stack size.


   DDiirreeccttoorryy SSeeaarrcchh LLiisstt
       Files specified in --IINNCCLLUUDDEE directives and LLOOAADD(())  function  calls  are
       first  checked for in the current working directory.  If not found, the
       following directory search order is used: Any directories specified  on
       the  command line using --II options, in the order specified; The list of
       directories from the  SSNNOOPPAATTHH  environment  variable,  if  defined;  If
       SSNNOOPPAATTHH is not defined, the SSNNOODDIIRR environment directory (or a compiled
       in default) is used to add the following:

       SNODIR/VERSION/local

       SNODIR/VERSION

       SNODIR/local

       SNODIR


EENNVVIIRROONNMMEENNTT
       SSNNOOPPAATTHH
              Is a list of directories delimited by colons (semi-colons on VMS
              and  Windows) appended to the Directory Search List (see above).
              NOTE!!  SSNNOOPPAATTHH,  SSNNOOBBOOLL__PPRREELLOOAADD__PPAATTHH  introduces  security  and
              portability issues!!

       SSNNOOBBOOLL__PPRREELLOOAADD__PPAATTHH
              Is  a  list  of source files delimited by colons (semi-colons on
              VMS and Windows) that will be read before  the  program  source.
              Like SSNNOOPPAATTHH, SSNNOOBBOOLL__PPRREELLOOAADD__PPAATTHH introduces security and porta-
              bility issues.

       SSNNOOLLIIBB
              (the sole search directory in versions of CSNOBOL4 prior to ver-
              sion  1.5)  is used to establish the base libary path if SSNNOOPPAATTHH
              is not defined.  See Directory Search List above.


SSEEEE AALLSSOO
       ssddbb(1),ssnnoobbooll44ddbbmm(3),ssnnoobbooll44ttccll(3),ssnnoobbooll44ttiimmee(3),ssnnoolliibb(3).


       http://www.snobol4.org
              All things SNOBOL4 related.


       http://www.snobol4.com
              Catspaw: commercial SPITBOL implementations, Free  SNOBOL4+  for
              DOS.


       http://www.snobol4.org/doc/burks/tutorial/contents.htm
              SNOBOL4 language tutorial (from Catspaw Vanilla SNOBOL4)


       http://www.snobol4.org/doc/burks/manual/contents.htm
              Catspaw Vanilla SNOBOL4 manual.


       ftp://ftp.snobol4.com/spitman.pdf
              Catspaw Macro SPITBOL manual


       [1] R. E. Griswold, J. F. Poage, and I. P. Polonsky
              _T_h_e  _S_N_O_B_O_L_4  _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e, 2nd ed., Prentice-Hall Inc.,
              1971.
              _(_a_k_a _t_h_e _g_r_e_e_n _b_o_o_k_)
              ftp://ftp.cs.arizona.edu/snobol4/gb.pdf


       [2] R. E. Griswold,
              _T_h_e _M_a_c_r_o _I_m_p_l_e_m_e_n_t_a_t_i_o_n _o_f _S_N_O_B_O_L_4,  W.  H.  Freeman  and  Co.,
              1972.
              Book  describing  the  implementation  techniques  used in Macro
              SNOBOL4.


       http://www.snobol4.org/docs/arizona/
              University of Arizona SNOBOL4 memos, formatted as PDF  files  by
              Scott  Marovich.   Includes  memo  s4d58,  which  describes each
              pseudo-instruction in the Snobol Implementation Language  (SIL),
              corrigendae  for  [1],  [2]  and  _S_t_r_i_n_g  _a_n_d _L_i_s_t _P_r_o_c_e_s_s_i_n_g _i_n
              _S_N_O_B_O_L_4.


AAUUTTHHOORR
       Philip L. Budne

       with help from:

       R. E. Griswold, J. F. Poage, and I. P. Polonsky

       Mark Emmer (code from SNOBOL4+)

       Viktors Berstis (code from Minnesota SNOBOL4)


DDIIAAGGNNOOSSTTIICCSS
       SNOBOL4 errors shown with &&EERRRRTTYYPPEE values.  Errors marked _f_a_t_a_l  cannot
       be curtailed by setting &&EERRRRLLIIMMIITT.

       1      "Illegal data type"

       2      "Error in arithmetic operation"

       3      "Erroneous array or table reference"

       4      "Null string in illegal context"

       5      "Undefined function or operation"

       6      "Erroneous prototype"

       7      "Unknown keyword"

       8      "Variable not present where required"

       9      "Entry point of function not label"

       10     "Illegal argument to primitive function"

       11     "Reading error"

       12     "Illegal i/o unit"

       13     "Limit on defined data types exceeded"

       14     "Negative number in illegal context"

       15     "String overflow"

       16     "Overflow during pattern matching" _f_a_t_a_l_.  See the --PP option.

       17     "Error in SNOBOL4 system" _f_a_t_a_l_.  Various internal errors.

       18     "Return from level zero" _f_a_t_a_l_.

       19     "Failure during goto evaluation" _f_a_t_a_l_.

       20     "Insufficient storage to continue" _f_a_t_a_l_.  See the --dd option.

       21     "Stack overflow" _f_a_t_a_l_.  See the --SS option.

       22     "Limit on statement execution exceeded" _f_a_t_a_l_.

       23     "Object exceeds size limit" _f_a_t_a_l_.

       24     "Undefined or erroneous goto" _f_a_t_a_l_.

       25     "Incorrect number of arguments" _f_a_t_a_l_.

       26     "Limit on compilation errors exceeded" _f_a_t_a_l_.

       27     "Erroneous END statement" _f_a_t_a_l_.

       28     "Execution  of  statement  with  compilation error" _f_a_t_a_l_.  Last
              error in standard SNOBOL4.

       29     "Erroneous INCLUDE statement" _f_a_t_a_l_.

       30     "Cannot open INCLUDE file" _f_a_t_a_l_.

       31     "Erroneous LINE statement" _f_a_t_a_l_.

       32     "Missing END statement" _f_a_t_a_l_.

       33     "Output error"

       34     "User interrupt" Interrupt character (SIGINT) was recieved.

       35     "Not in a SETEXIT handler" Attempt to branch to CCOONNTTIINNUUEE,  SSCCOONN--
              TTIINNUUEE, or AABBOORRTT when no unhandled error condition present.

BBUUGGSS
       I/O retains some record oriented flavor.

       I/O is still tied to unit numbers.

       "Dynamic" storage cannot be expanded after startup.

       Integer math can never "fail", even on overflow.

       Oversize integer constants may not be detected.

       This manual page is too long, and should be split up!

       There should be a ssnnoobbooll44ffuunncc(1) man page which describes all intrinsic
       functions (this page only includes extensions).




SNOBOL                            26 Sep 2013                       SNOBOL4(1)
